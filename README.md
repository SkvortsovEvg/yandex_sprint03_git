[GIT](#git)

[1. Команды BASH](#commandsBASH)

[2. Команды GIT](#commandsGIT)

[3. Форк и ветка](#forkAndBranch)

[4. Об SSH](#aboutSSH)

  [4.1. Проверка наличия SSH-ключа](#checkSSH)

  [4.2. Инструкция по генерации SSH-ключа](#generationSSH)

  [4.3. Инструкция по связыванию SSH-ключа и GitHub-аккаунта](#bindSSHAndGitHub)

[5. Отправка на GitHub с помощью IntelliJ IDEA](#sendToGITWithIDEA)

[6. git log](#gitLog)

  [6.1. Хеш — идентификатор коммита](#hashIDCoLogmmit)

  [6.2. Исследуем лог](#researchLog)

  [6.3. HEAD - всему голова](#everythingHEAD)

[7. git status](#gitStatus)

  [7.1. Статусы untracked/tracked, staged и modified](#otherStatus)

  [7.2. Типичный жизненный цикл файла в Git](#lifeFileInGit)

  [7.3. Какие состояния показывает команда git status](#statesGitStatus)

[8. Оформление сообщений к коммитам](#messageInCommit)

  [8.1. Зачем вообще писать сообщения](#whyMessageInCommit)

  [8.2. Стили оформления сообщений коммитов](#visualStyleMessageCommit)

    [8.2.1. Корпоративный](#visualStyleMessageCommitCorporate)

    [8.2.2. Conventional Commits](#visualStyleMessageCommitConventionalCommits)

    [8.2.3. GitHub-стиль](#visualStyleMessageCommitGitHubStyle)

<a name="git"><h1>GIT</h1></a>

Историю проектов программистов хранит отдельная программа — **система контроля версий** (англ. _Version Control System_, или коротко _VCS_).

Для обозначения систем контроля версий используют не только аббревиатуру VCS, но и **SCM** (от англ. _Source Control Management_ — «система управления исходным кодом»).

Одно изменение или группу изменений в VCS называют **ревизией** или **версией**. Каждая такая ревизия содержит информацию о том, что изменилось, кто внёс изменения, когда это было и иногда комментарии к изменению.  
На своем ПК я использую Windows 11, поэтому далее разговор ведется с учетом данной ОС.

В повседневной работе большинство пользователей Git используют консоли с наборами команд, похожие на те, что применяют в macOS и Linux. Вы будете учиться делать то же самое. Для этого нужно установить специальный консольный инструмент для Windows, который называется **Git Bash**. Данная программа является консольной.

<a name="commandsBASH"><h2>1. Команды BASH</h2></a>

Для работы с помощью консольного приложения необходимо знать некоторые команды. Стоит упомянуть о том, что символ **~** - домашняя директория, **..** - на каталог выше, **.** - текущая папка. 

1. **pwd** - показывает рабочую папку.
2. **cd** - сменить директорию.
3. **ls** - отобразить содержимое директории. Флаг **-a** выводит расширенный список. В нём отобразятся все скрытые файлы, которые начинаются с символа **.** (например, файлы конфигурации). Также происходит работа с **~**.
4. **touch** - создать файл: **touch имя_файла.расширение_файла**. Например, **touch file.txt**
5. **mkdir** - создать директорию: **mkdir new_dir** - создается новая папка в текущей папке. Также можно создать целую структуру директорий одной командой с помощью флага **-p**: **mkdir -p dir1/dir-inside/dir-deeper-inside**.
6. **cp** - копирование файлов: **cp что_копируем куда_копируем**. Например, **cp d:/file.txt c:/first-project/**
7. **mv** - перемещение файлов и папок: **mv что_перемещаем куда_перемещаем**. Например, **mv d:/file01.txt c:/first-project/**
8. **cat** - чтение файлов: **cat file.txt**. Команда **cat** работает только с текстовыми файлами. Вывести этой командой файл другого типа (например, изображение) не получится.
9. **rm** - удалить файл: **rm file02.txt** - происходит удаление файла **file02.txt** в текущей папке.
10. **rmdir** - удаление папки (но пустой папки!): **rmdir c:/first-project/images** - удаляется **_пустая(!)_** папка **images** в папке **c:/first-project**.
11. **rm -r** - удаление папки и файлов, положенных в данную папку: **rm -r c:/first-project/images** - удаляется папка полностью.

<a name="commandsGIT"><h2>2. Команды GIT</h2></a>

1. **git version** - показывает версию Git.
2. **git config** - конфигурация Git. Вызывается так: 
- **git config --global user.name** _имя_пользователя_ -  необходимо указать своё имя или никнейм,
- **git config --global user.email** _почта_пользователя_ - указывается электронная почта.

Все глобальные настройки Git хранит в файле **.gitconfig** в домашней директории. Команда запишет в этот файл указанные имя и почту. Чтобы убедиться в этом, можно вызвать команду для чтения файлов: 

```BASH
$ cat ~/.gitconfig 
```

либо 

```BASH
$ git config --list
```

3. **git init** - cделать папку репозиторием.
4. **rm -rf .git** - если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить».
5. **git status** - проверить состояние репозитория.
6. **git add** - подготовить файлы к сохранению. **git add --all** - позволяет подготовить к сохранению все файлы в репозитории. Также можно добавить текущую папку целиком — в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке в Bash позволяет точка: **git add .**.
7. **git commit** - выполнить коммит, точнее **git commit -m 'Комментарий'**.
8. **git log** - просмотреть историю коммитов.
9. **git push** - отправить изменения на удалённый репозиторий. В первый раз эту команду нужно вызвать с флагом **-u** и параметрами **origin** (имя удалённого репозитория) и **main** или **master** (название текущей ветки). Флаг **-u** свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории, так же и здесь нужно дополнительно связать ветки: **git push -u origin main**. Если вы указывали кодовую фразу при [настройке SSH-ключей](#generationSSH), её нужно будет ввести.
10. **git clone _адрес_** - клонировать репозиторий  
 по https:

```BASH
$ git clone https://github.com/yandex-praktikum/git-clone-practice.git
```

 или ssh: 

```BASH
$ git clone git@github.com:yandex-praktikum/git-clone-practice.git
```

11. **git remote -v** - проверка того, что репозитории связаны.
12. **git clone** - клонируем форк на компьютер. Клонировать форк — значит скачать его, чтобы работать с кодом на своём компьютере. Тут нам и пригодится [SSH](#aboutSSH).

```BASH
$ git clone git@github.com:your-nickname/your-project.git
```
Замените _your-nickname_ на ваше имя пользователя на GitHub, а _your-project_ на название проекта. Проще всего их найти прямо наверху страницы репозитория.  
Если вы правильно настроили SSH-ключи, Git скопирует репозиторий на ваш компьютер.

<a name="forkAndBranch"><h2>3. Форк и ветка</h2></a>

Между понятиями **форк** и **ветка** есть важные различия, особенно в контексте систем контроля версий, таких как Git.

1. **Ветка (Branch)**:

- Ветка — это отдельная линия разработки в рамках одного репозитория. Она позволяет разработчикам работать над новыми функциями или исправлениями, не затрагивая основную (обычно главную) ветку проекта.

- Ветки создаются для изоляции изменений, и их можно объединять (merge) с основной веткой после завершения работы.

- Все ветки находятся в одном репозитории и могут легко взаимодействовать друг с другом.

2. **Форк (Fork)**:

- Форк — это полная копия репозитория, созданная на другом уровне, обычно на платформе, такой как GitHub или GitLab. Он позволяет пользователю работать с проектом независимо от оригинального репозитория.

- Форки часто используются для внесения изменений в чужие проекты. После внесения изменений пользователь может создать запрос на слияние (pull request), чтобы предложить свои изменения оригинальному репозиторию.

- Форк позволяет пользователям экспериментировать и вносить изменения без риска повредить оригинальный проект.

Таким образом, основное различие заключается в том, что ветка используется для работы внутри одного репозитория, а форк создает независимую копию репозитория для работы над проектом.

<a name="aboutSSH"><h2>4. Об SSH</h2></a>

**SSH** (англ. Secure Shell — «безопасная оболочка») — сетевой протокол прикладного уровня, позволяющий производить удалённое управление операционной системой и туннелирование TCP-соединений (например, для передачи файлов). Схож по функциональности с протоколами Telnet и rlogin, но, в отличие от них, шифрует весь трафик, включая и передаваемые пароли. SSH допускает выбор различных алгоритмов шифрования.  
Файлы настроек хранятся по пути **~/.ssh/**.

SSH использует пару ключей для обеспечения безопасности — публичный и приватный:
* **Приватный ключ** (англ. _private key_) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
* **Публичный ключ** (англ. _public key_) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.  
Только вы можете расшифровать данные приватным ключом, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют **SSH-пару**.

<a name="checkSSH"><h3>4.1. Проверка наличия SSH-ключа</h3></a>

Прежде чем генерировать SSH-ключи, убедитесь, что у вас их ещё нет. По умолчанию директория с SSH-ключами находится в домашней директории. Перейдите в неё.

```BASH
$ cd ~
```

Обычно SSH-ключи находятся в директории **.ssh/**. Проверить наличие этой директории и файлов в ней можно с помощью следующей команды.

```BASH
$ ls -la .ssh/
```

Если папка пустая или её нет, всё в порядке. Если есть файлы с похожими названиями, SSH-ключи уже создавались:
* id_dsa.pub
* id_ecdsa.pub
* id_ed25519.pub
* id_rsa.pub

Если вы не создавали эти файлы, удалите их все.

<a name="generationSSH"><h3>4.2. Инструкция по генерации SSH-ключа</h3></a>

1. Для генерации SSH-пары можно использовать программу ssh-keygen. Откройте терминал и введите следующую команду:
```BASH
 $ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.

Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519. Ничего страшного: используйте другой алгоритм.

```BASH
 $ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"
```

2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите Enter.

```BASH
 > Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter]
```

Теперь в указанной директории появится пара ключей.

3. Программа запросит **кодовую фразу** (англ. _passphrase_) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите Enter, а затем ещё раз Enter.

```BASH
 > Enter passphrase (empty for no passphrase): [Type a passphrase]
 > Enter same passphrase again: [Type passphrase again]
```

4. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите следующую команду.

```BASH
$ ls -a ~/.ssh
```

На экране должны появиться два файла — один с расширением .pub, другой — без. Файл в .pub — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения .pub — приватный. Ни в коем случае не передавайте его никому!

<a name="bindSSHAndGitHub"><h3>4.3. Инструкция по связыванию SSH-ключа и GitHub-аккаунта</h3></a>

1. После выполнения ssh-keygen в директории ~/.ssh есть два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали). Скопируйте содержимое файла с публичным ключом в буфер обмена.

```BASH
 # скопировать содержимое ключа в буфер обмена:
 $ clip < ~/.ssh/id_rsa.pub
 # для ed25519:
 $ clip < ~/.ssh/id_ed25519.pub
 ```

  Если **clip** не сработает, выведите содержимое файла с помощью 

```BASH
  $ cat ~/.ssh/id_rsa.pub 
```
  или 

```BASH
  $ cat ~/.ssh/id_ed25519.pub 
```
  и скопируйте вывод в буфер обмена из консоли.

  2. Перейдите на GitHub и выберите пункт **Settings** (англ. _«настройки»_) в меню аккаунта.

  3. В меню слева нажмите на пункт **SSH and GPG keys**.

  4. В открывшейся вкладке выберите **New SSH key** (англ. _«новый SSH-ключ»_).

  5. В поле **Title** (англ. _«заголовок»_) напишите название ключа. Например, **Personal key** (англ. _«личный ключ»_).

  6. В поле **Key type** (англ. _«тип ключа»_) должно быть **Authentication Key** (англ. _«ключ аутентификации»_).

  7. В поле **Key** скопируйте ваш ключ из буфера обмена.

  8. Нажмите на кнопку **Add SSH key** (англ. _«добавить SSH-ключ»_).

  9. Проверьте правильность ключа с помощью следующей команды.

  ```BASH
  $ ssh -T git@github.com
  ```

Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение.

```BASH
 The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?
```

Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.  
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub по этой ссылке. Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите _yes_, чтобы продолжить. Вы увидите приветствие на экране.

```BASH
 Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access.
```

<a name="sendToGITWithIDEA"><h2>5. Отправка на GitHub с помощью IntelliJ IDEA</h2></a>

**git init**

1. Откройте папку проекта в IntelliJ IDEA с помощью кнопки **Open** (англ. «открыть»). Для проектов, которые не находятся под контролем Git, следующим шагом будет инициализация Git-репозитория. Выполните её: выберите пункт меню **VCS** → **Enable Version Control Integration…** (англ. «система контроля версий» → «включить интеграцию с системой контроля»).

![Включить интеграцию с системой контроля](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_001.png "Текст 001")

В появившемся окне выберите систему Git, а затем нажмите **ОК**.

![Git and OK](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_002.png "Текст 002")

Для текущего проекта станет доступна панель инструментов Git. Её можно найти в левом нижнем углу.

![Git и левый нижний угол](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_003.png "Текст 003")

Также в меню Git и во многих контекстных меню станут доступны пункты, которые связаны с интеграцией контроля версий. Например, сравнение и откат версий, просмотр истории изменений, просмотр авторов изменений и так далее. Об этих инструментах мы ещё расскажем далее в курсе.

Для проектов с уже настроенной системой контроля версий панель Git доступна сразу после открытия. Рассмотрим её базовый интерфейс. Он состоит из дерева веток и списка коммитов — сейчас этот список пустой. Дерево веток содержит только локальную ветку **master**, тоже пустую.

![Empty master](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_004.png "Текст 004")

В работе вам также может пригодиться вкладка **Console**, которая находится справа от текущей вкладки **Log**. На самом деле IDEA просто использует утилиты Git, поэтому выполняет все нужные команды в консоли — совсем как вы в предыдущих темах. После того как вы поработаете с пунктами меню Git или нажмёте кнопки на панели быстрых действий, вы сможете просмотреть список выполненных IDEA команд на вкладке **Console**.

**git remote add origin <url>**

2. Можно продолжить использовать Git-репозиторий локально. В этом случае он будет просто хранить историю изменений проекта. Но всё же основное назначение Git — передача изменений между копиями репозитория: теми, которые хранятся у разных участников проекта и на центральном сервере. Такой центральный сервер называется **remote** (англ. _«удалённый»_). Он нужен для синхронизации изменений между участниками.

Вы уже создавали удалённый репозиторий на платформе GitHub в одной из прошлых тем. Создайте ещё один и потренируйтесь связывать локальный и удалённый репозитории через графический интерфейс IDE. Вам нужно добавить удалённый репозиторий в список **remote**. Для этого кликните кнопкой мыши по пункту меню **Git → Manage Remotes** (англ. _«управлять списком remote»_).

![Manage Remotes](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_005.png "Текст 005")

Нажмите на **+**. IDEA предложит указать первый **remote** для вашего репозитория. По традиции он называется **origin** (англ. _«источник»_). Заполните его ссылкой на ваш репозиторий GitHub и нажмите OK.

![link repository](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_006.png "Текст 006")

Репозиторий готов к первому коммиту и синхронизации!

**git commit**

3. Выполнение коммита в IDEA немного отличается от того, как вы это делали в консоли. Графический интерфейс позволяет совместить подготовительные операции **git status** и **git add/rm** в окне коммита, которое расположено на боковой панели слева. Вызвать это окно можно из меню **Git → Commit**. Также можно нажать на кнопку **✓ (Commit…)** на панели быстрых действий в правом верхнем углу экрана IDE.

![Commit](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_007.png "Текст 007")

Затем отметьте файлы, которые хотите добавить в репозиторий. Заполните сообщение о коммите в окне ввода и нажмите кнопку **Commit** внизу. После этого выполнятся все консольные команды, в том числе **git commit**.

![git commit](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_008.png "Текст 008")

Изменения зафиксированы. Убедитесь в этом: перейдите в панель **Git** и выберите главную ветку **master** или **main**, если она ещё не выбрана. Вы увидите свой новый коммит.

**git push**

4. Последний шаг — отправить локальные изменения в удалённый репозиторий, который был указан в качестве **remote**. Вызовите команду меню **Git → Push** или нажмите на кнопку **➚ (Push…)** на панели быстрых действий.

![Push](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_009.png "Текст 009")

Откроется диалог подтверждения операции. Он нужен, чтобы вы убедились в правильности своих действий с удалённым репозиторием. Если всё в порядке, нажмите на кнопку **Push**.

![git push](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_010.png "Текст 010")

Изменения отправлены в удалённый репозиторий! Проверьте страницу проекта на GitHub: коммит должен появиться в удалённой копии исходного кода.

<a name="gitLog"><h2>git log</h2></a>

<a name="hashIDCommit"><h3>6.1. Хеш — идентификатор коммита</h3></a>

В процессе работы с Git вам будет часто встречаться понятие «хеш коммита». Эти странные строчки с бессмысленным (на первый взгляд) набором букв и цифр вы могли видеть, когда вызывали команду `git log` и выводили историю коммитов.

![git hash](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_011.png "Текст 011")

**Хеширование** (от англ. *hash*, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. *fingerprint*).

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или **родительский** (англ. *parent*), коммит. Git хеширует (преобразует) эту информацию с помощью алгоритма **SHA-1** (от англ. _**S**ecure **H**ash **A**lgorithm_ — «безопасный алгоритм хеширования») и получает для каждого коммита свой `уникальный` хеш — результат хеширования.

В то время, как результат работы метода `hashCode()` — это целое число, результат хеширования в Git — символьная строка. Она относительно коротка (40 символов в случае SHA-1) и состоит из цифр *0—9* и латинских букв *A—F* (неважно, заглавных или строчных). Хеш обладает следующими важными свойствами:

* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;

* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

`💡Чтобы убедиться в этом, поэкспериментируйте с SHA-1 на этом сайте — попробуйте ввести в поле input (англ. «ввод») разные символы, слова или предложения и понаблюдайте, как меняется хеш в поле output (англ. «вывод»).`

Git хранит таблицу соответствий `хеш → информация о коммите`. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.

Все хеши и таблицу `хеш → информация о коммите` Git сохраняет в служебные файлы. Они находятся в скрытой папке `.git` в репозитории проекта.

<a name="researchLog"><h3>6.2. Исследуем лог</h3></a>

После вызова `git log` появляется список коммитов с их описанием.

![git log](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_012.png "Текст 012")

Вот из каких элементов состоит описание:

1. Строка из цифр и латинских букв после слова **commit** — это уже знакомый вам хеш коммита.

2. **Author** — имя автора и его электронная почта.

3. **Date** — дата и время создания коммита.

4. Сообщение к коммиту.

Если в репозитории уже много коммитов — например, сотни или тысячи, — пригодится сокращённый лог. С ним можно быстро найти нужный коммит по описанию.

Сокращённый лог вызывают командой `git log` с флагом `--oneline` (англ. *«одной строкой»*). При этом в терминале появятся только первые несколько символов хеша каждого коммита и комментарии к ним.

![git log online](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_013.png "Текст 013")

Сокращённый хеш (первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда `git log --oneline` автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.

💡 Обратите внимание: если выход из просмотра логов не произошёл автоматически, нажмите клавишу `Q` (от англ. _**Q**uit_ — «выйти») в английской раскладке клавиатуры.

<a name="everythingHEAD"><h3>6.3. HEAD - всему голова</h3></a>

При вызове команды `git log` вы также могли заметить надпись `(HEAD -> master)` после хеша одного из коммитов.

![git log head](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_014.png "Текст 014")

Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый).

Убедитесь в этом с помощью терминала. Перейдите в папку `.git` командой `cd`. Посмотрите содержимое файла `HEAD` командой `cat`.

```BASH
$ pwd # посмотрели, где мы
/Users/user/dev/first-project

$ cd .git/
$ ls # посмотрели, какие есть файлы
COMMIT_EDITMSG  ORIG_HEAD  description  index  logs/     refs/
HEAD            config     hooks/       info/  objects/

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/master # в файле вот такая ссылка
```

Внутри `HEAD` — ссылка на служебный файл: `refs/heads/master` (или `refs/heads/main` в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

```BASH
$ cat refs/heads/master # взяли ссылку из файла HEAD
# внутри хеш
e007f5035f113f9abca78fe2149c593959da5eb7

$ git log 
# сверяем с хешем последнего коммита
commit e007f5035f113f9abca78fe2149c593959da5eb7
Author: John Doe <johndoe@example.com>
Date:   Tue Mar 28 00:26:53 2023 +0300

    Добавить амбиций в список дел

... # другие коммиты
```

Когда вы делаете коммит, Git обновляет `refs/heads/master` — записывает в него хеш последнего коммита. Получается, что `HEAD` тоже обновляется, так как ссылается на `refs/heads/master`.

При работе с Git указатель `HEAD` используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово `HEAD` — Git поймёт, что вы имели в виду последний коммит.

<a name="gitStatus"><h2>7. git status</h2></a>

Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого можно избежать, если не забывать проверять состояния (или статусы) файлов командой `git status`. В этом уроке разберём подробнее, в каких состояниях могут находиться файлы в репозитории и как читать вывод `git status`.

<a name="otherStatus"><h3>Статусы untracked/tracked, staged и modified</h3></a>

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

* `untracked` (англ. «неотслеживаемый»)

Новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.

* `staged` (англ. «подготовленный»)

После выполнения команды `git add` файл попадает в **staging area** (от англ. *stage* — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.

💡 Staging area также называют **index** (англ. «каталог») или **cache** (англ. «кеш»), а состояние файла `staged` иногда называют `indexed` или `cached`. Все три варианта могут встречаться в документации и в качестве флагов команд Git. А также в интернете — например, в вопросах и ответах на сайте Stack Overflow.

* `tracked` (англ. «отслеживаемый»)

Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в staging area командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.

* `modified` (англ. «изменённый»)

Состояние `modified` значит, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

Вот что ещё важно учесть:

* Для файлов в состояниях `staged` и `modified` обычно не указывается, что они также `tracked`, потому что это состояние подразумевается.

* Команда `git add` добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете `git add file.txt`, а затем измените `file.txt`, то новое содержимое файла не будет находиться в staging. Git сообщит об этом с помощью статуса `modified`: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить `git add file.txt` ещё раз.

<a name="lifeFileInGit"><h3>Типичный жизненный цикл файла в Git</h3></a>

Может показаться, что файлы в репозитории попадают в разные состояния хаотично. На практике это не так, и у большинства файлов вполне предсказуемый путь.

![lifeFile](https://github.com/SkvortsovEvg/yandex_sprint03_git/blob/main/images/GitAndIdea/pic_015.png "Текст 015")

1. Файл только что создали. Git ещё не отслеживает его содержимое. Состояние: `untracked`.

2. Файл добавили в staging area с помощью `git add`. Состояние: `staged` (+ `tracked`).

* Возможно, изменили файл ещё раз. Состояния: `staged`, `modified` (+ `tracked`).  
 Обратите внимание: `staged` и `modified` у одного файла, но у разных его версий. 

* Ещё раз выполнили `git add`. Состояние: `staged` (+ `tracked`).

3. Сделали коммит с помощью `git commit`. Состояние: `tracked`.

4. Изменили файл. Состояние: `modified` (+ `tracked`).

5. Снова добавили в staging area с помощью `git add`. Состояния: `staged` (+ `tracked`).

6. Сделали коммит. Состояния: `tracked`.

7. Повторили пункты 4−7 много-много раз.

<a name="statesGitStatus"><h3>Какие состояния показывает команда git status</h3></a>

Большинство файлов в типичном проекте будут находиться в состоянии `tracked` (то есть закоммичены и не изменены после коммита). Вы не увидите это состояние в выводе команды `git status` — иначе она бы каждый раз выводила список вообще всех файлов проекта. В итоге `git status` показывает только следующие состояния файлов:

* `staged` (`Changes to be committed` в выводе `git status`);

* `modified` (`Changes not staged for commit`);

* `untracked` (`Untracked files`).

Потренируйтесь читать вывод `git status` вместе с нами. Инициализируйте новый репозиторий `~/dev/git-status-lesson`. Создайте в нём файл `README.md` и закоммитьте его.

```BASH
$ cd ~/dev
$ mkdir git-status-lesson
$ cd git-status-lesson
$ git init
# тут Git выведет что-нибудь, но мы это пропустим
$ touch README.md
$ git add README.md
$ git commit -m 'Добавить README'
# по традиции первым создадим и закоммитим файл README.md
```

Дальше вы будете добавлять в репозиторий файлы и проверять их статусы. Мы рассмотрим четыре примера состояний, в которых может находиться ваш репозиторий.

1. **Нет ни `staged`-, ни `modified`-, ни `untracked`-файлов.**

Если ничего не менять в `git-status-lesson` после первого коммита, то в нём не должно быть ни изменённых файлов (`modified`), ни новых (`untracked`), ни добавленных в список на коммит (`staged`). Вызовите команду `git status`. Её вывод будет примерно таким.

```BASH
$ git status
On branch master
nothing to commit, working tree clean 
```

Это означает, что в репозитории нет новых или изменённых файлов. Последняя строка `nothing to commit, working tree clean` переводится как «нечего коммитить, рабочая директория чиста». Первая строка `On branch master` сообщает, что текущая ветка — `master`.

2. **Найдены неотслеживаемые файлы.**

Создайте в папке `~/dev/git-status-lesson` файл `fileA.txt`. Теперь в репозитории есть новый файл в состоянии `untracked`. Снова вызовите команду `git status`. Результат будет таким.

```BASH
$ touch fileA.txt
$ git status
On branch master
Untracked files: # найдены неотслеживаемые файлы
  (use "git add <file>..." to include in what will be committed)
        fileA.txt

nothing added to commit but untracked files present (use "git add" to track)
```

Файл `fileA.txt` отображается в секции неотслеживаемых файлов — `Untracked files`. Это значит, что он не был добавлен в репозиторий через `git add`.

В выводе `git status` есть подсказка, какую команду использовать, чтобы добавить файл в список на коммит: `Use git add <file> to include in what will be committed` (англ. «используйте `git add <file>`, чтобы добавить в список на коммит»). Добавьте `fileA.txt` в staging area с помощью `git add` и снова запросите `git status`.

```BASH
$ git add fileA.txt 
$ git status
On branch master
Changes to be committed: # новая секция
  (use "git restore --staged <file>..." to unstage)
        new file:   fileA.txt
```

Теперь `fileA.txt` находится в секции `Changes to be committed` (англ. «изменения, которые попадут в коммит»). Если сейчас выполнить коммит, то в репозитории будет зафиксирована текущая версия этого файла. Закоммитьте его.

```BASH
$ git commit -m 'Добавить файл fileA.txt'
# тут будет вывод комманды commit, он нас не интересует
$ git status
On branch master
nothing to commit, working tree clean
```

3. **Найдены изменения, которые не войдут в коммит.**

Теперь откройте файл `fileA.txt` и добавьте в него несколько слов — например, `Это файл A!`. Сохраните `fileA.txt` и вызовите команду `git status`. Её результат будет такой.

```BASH
# внесли в fileA.txt правки
# запросили статус
$ git status 
On branch master
Changes not staged for commit: # ещё одна секция
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   fileA.txt
```

Файл `fileA.txt` был изменён, но не добавлен в staging area после этого. Так он оказался в секции `Changes not staged for commit` (англ. «изменения, которые не подготовлены к коммиту»), соответствующей статусу `modified`. Подготовьте правки к коммиту через `git add`.

```BASH
$ git add fileA.txt
$ git status
On branch master
Changes to be committed: # все изменения готовы к коммиту
  (use "git restore --staged <file>..." to unstage)
        modified:   fileA.txt
```

Теперь в коммит попадёт уже новая версия файла `fileA.txt`. Обратите внимание: хотя вывод команды `git status` похож на тот, что был после первого добавления файла `fileA.txt`, они отличаются. Когда новый файл попадает в staging area, перед его названием указывается `new file`: `new file: fileA.txt`. Если файл уже однажды попадал в историю (с помощью коммита) и был изменён, после выполнения `git add` он будет записан уже так: `modified: fileA.txt`.

4. **Файл добавлен в staging area, но после этого изменён.**

Вы добавили файл в staging area, но перед коммитом вспомнили нечто важное. Например, вместо одного восклицательного знака в конце строки `Это файл A!` нужно поставить три.

Откройте текстовый редактор и добавьте нужные правки. Теперь можно выполнить коммит, но в любой непонятной ситуации сначала стоит вызвать `git status`. Он покажет следующее.

```BASH
# изменили fileA.txt
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
          modified:   fileA.txt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
          modified:   fileA.txt
```

Файл попал и в `staged` (`Changes to be committed`), и в `modified` (`Changes not staged for commit`). В staging area находится версия файла с одним восклицательным знаком, а в `Changes not staged for commit` — уже изменённая версия, с тремя. Чтобы закоммитить самую свежую версию файла, нужно снова выполнить `git add` перед коммитом. Готово!

<a name="messageInCommit"><h2>Оформление сообщений к коммитам</h2></a>

То, как написаны сообщения к коммитам, тоже может подчиняться определённым правилам. Иногда эти правила продиктованы культурой команды, а иногда техническими ограничениями. Например, в выводе команды `git log --oneline` умещается максимум 72 первых символа сообщения, поэтому многие правила включают пункт: «Сообщение не должно быть длиннее 72 символов».

Далее рассмотрим правила оформления сообщений к коммитам.

<a name="whyMessageInCommit"><h3>Зачем вообще писать сообщения</h3></a>

У каждого коммита в Git есть сообщение — то, что передаётся после параметра `-m`. Например: `git commit -m "Добавить урок про оформление сообщений коммитов"`.

Сообщения коммитов можно сравнить с надписями на коробках в кладовке. Если надписей нет, то нужную коробку будет сложно найти: придётся заглянуть в каждую, чтобы понять, что там. А если надписи есть, то нужная найдётся сразу.

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

* относительно коротким, чтобы его было легко прочитать;

* информативным.

Пример: `Исправление опечатки в заголовке главной страницы на хорватском`. Плюсы:

* `Исправление опечатки` значит, что исправлена ошибка, которая была допущена при наборе. Такое исправление не меняет смысл. То есть, например, главному редактору не нужно перепроверять этот заголовок.

* `На хорватском` говорит о том, что переводчикам на другие языки этот коммит можно смело пропускать.

* `В заголовке главной страницы` указывает, где произошли изменения. Если, например, кто-то зайдёт на сайт и ему не понравится новый заголовок, он легко найдёт по истории (`git log`) автора этого коммита и спросит у него, почему заголовок теперь такой.

Плохой пример: `Исправлена опечатка`. Это сообщение даёт мало информации. В такой коммит придётся «заглядывать» — разбираться, что именно поменялось и зачем.

<a name="visualStyleMessageCommit"><h3>Стили оформления сообщений коммитов</h3></a>

Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: `Исправить сообщение об ошибке E123`, кто-то — глаголы в прошедшем времени: `Исправил…`, кто-то — существительные: `Исправление…`.

Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.

Например, правила могут быть такие:

1. длина сообщения от 30 до 72 символов;

2. первое слово — глагол в инфинитиве («исправить», «дополнить», «добавить» и другие);

3. и т.д.

<a name="visualStyleMessageCommitCorporate"><h4>Корпоративный</h4></a>

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, `LGS-239` значит, что это 239-я задача в проекте **LGS** (сокращение от англ. _**l**o**g**i**s**tics_ — «логистика»).

В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

```BASH
$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"
```

Какие-то команды могут договариваться, с какой части речи начинать сообщение и какой длины оно должно быть, какие-то — нет. Но требование о наличии Jira-ID обычно строгое: оно позволяет автоматически связывать коммиты с задачами и проектами.

<a name="visualStyleMessageCommitConventionalCommits"><h4>Conventional Commits</h4></a>

Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. А вот использовать его для других типов проектов было бы неудобно.

Conventional Commits предлагает такой формат коммита: `<type>: <сообщение>`. Первая часть `type` — это тип изменений. Таких типов достаточно много. Вот два примера:

* `feat`  (сокращение от англ. *feature*) — для новой функциональности;

* `fix` (от англ. «исправить», «устранить») — для исправленных ошибок.

Например, сообщение может быть таким:

```BASH
git commit -m "feat: добавить подсчёт суммы заказов за неделю"
```

<a name="visualStyleMessageCommitGitHubStyle"><h4>8.2.3. GitHub-стиль</h4></a>

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка **задач** (англ. *issue*) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать `#<номер задачи>`. Например, вот так:

```BASH
$ git commit -m "Исправить #334, добавить график температуры"
```

В таком случае GitHub свяжет коммит и задачу.

💡 Для сообщений на русском языке часто рекомендуют использовать инфинитивы. Например: `Добавить тесты для PipkaService`, `Исправить ошибку #123` и так далее.
Для сообщений на английском рекомендуется использовать **повелительное наклонение** (англ. *imperative*). Например: `Use library mega_lib_300`, `Fix exit button` и так далее.

Эти рекомендации сложились исторически, и им следуют многие проекты.